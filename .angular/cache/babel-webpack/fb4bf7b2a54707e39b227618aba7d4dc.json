{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Directive, EventEmitter, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { Subject, Observable, ReplaySubject, merge, combineLatest, fromEvent } from 'rxjs';\nimport { filter, mergeMap, startWith, map, share, takeUntil, take, takeLast, count, pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\n\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(className => renderer.addClass(element.nativeElement, className));\n  }\n}\n\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(className => renderer.removeClass(element.nativeElement, className));\n  }\n}\n\nclass DraggableHelper {\n  constructor() {\n    this.currentDrag = new Subject();\n  }\n\n}\n\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\n\nDraggableHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableHelper, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\n\n\nclass DraggableScrollContainerDirective {\n  /**\n   * @hidden\n   */\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n\n}\n\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n  return new (t || DraggableScrollContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nDraggableScrollContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DraggableScrollContainerDirective,\n  selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggableScrollContainer]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }];\n  }, null);\n})();\n\nclass DraggableDirective {\n  /**\n   * @hidden\n   */\n  constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.vcr = vcr;\n    this.scrollContainer = scrollContainer;\n    this.document = document;\n    /**\n     * The axis along which the element is draggable\n     */\n\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\n     * Snap all drags to an x / y grid\n     */\n\n    this.dragSnapGrid = {};\n    /**\n     * Show a ghost element that shows the drag when dragging\n     */\n\n    this.ghostDragEnabled = true;\n    /**\n     * Show the original element when ghostDragEnabled is true\n     */\n\n    this.showOriginalElementWhileDragging = false;\n    /**\n     * The cursor to use when hovering over a draggable element\n     */\n\n    this.dragCursor = '';\n    /*\n     * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n     */\n\n    this.autoScroll = {\n      margin: 20\n    };\n    /**\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n     */\n\n    this.dragPointerDown = new EventEmitter();\n    /**\n     * Called when the element has started to be dragged.\n     * Only called after at least one mouse or touch move event.\n     * If you call $event.cancelDrag$.emit() it will cancel the current drag\n     */\n\n    this.dragStart = new EventEmitter();\n    /**\n     * Called after the ghost element has been created\n     */\n\n    this.ghostElementCreated = new EventEmitter();\n    /**\n     * Called when the element is being dragged\n     */\n\n    this.dragging = new EventEmitter();\n    /**\n     * Called after the element is dragged\n     */\n\n    this.dragEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.pointerDown$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerMove$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerUp$ = new Subject();\n    this.eventListenerSubscriptions = {};\n    this.destroy$ = new Subject();\n    this.timeLongPress = {\n      timerBegin: 0,\n      timerEnd: 0\n    };\n  }\n\n  ngOnInit() {\n    this.checkEventListeners();\n    const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap(pointerDownEvent => {\n      // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n      // stop mouse events propagating up the chain\n      if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n        pointerDownEvent.event.stopPropagation();\n      } // hack to prevent text getting selected in safari while dragging\n\n\n      const globalDragStyle = this.renderer.createElement('style');\n      this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n      this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n      requestAnimationFrame(() => {\n        this.document.head.appendChild(globalDragStyle);\n      });\n      const startScrollPosition = this.getScrollPosition();\n      const scrollContainerScroll$ = new Observable(observer => {\n        const scrollContainer = this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window';\n        return this.renderer.listen(scrollContainer, 'scroll', e => observer.next(e));\n      }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));\n      const currentDrag$ = new Subject();\n      const cancelDrag$ = new ReplaySubject();\n      this.zone.run(() => {\n        this.dragPointerDown.next({\n          x: 0,\n          y: 0\n        });\n      });\n      const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n      const pointerMove = combineLatest([this.pointerMove$, scrollContainerScroll$]).pipe(map(([pointerMoveEvent, scroll]) => {\n        return {\n          currentDrag$,\n          transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n          transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n          clientX: pointerMoveEvent.clientX,\n          clientY: pointerMoveEvent.clientY,\n          scrollLeft: scroll.left,\n          scrollTop: scroll.top,\n          target: pointerMoveEvent.event.target\n        };\n      }), map(moveData => {\n        if (this.dragSnapGrid.x) {\n          moveData.transformX = Math.round(moveData.transformX / this.dragSnapGrid.x) * this.dragSnapGrid.x;\n        }\n\n        if (this.dragSnapGrid.y) {\n          moveData.transformY = Math.round(moveData.transformY / this.dragSnapGrid.y) * this.dragSnapGrid.y;\n        }\n\n        return moveData;\n      }), map(moveData => {\n        if (!this.dragAxis.x) {\n          moveData.transformX = 0;\n        }\n\n        if (!this.dragAxis.y) {\n          moveData.transformY = 0;\n        }\n\n        return moveData;\n      }), map(moveData => {\n        const scrollX = moveData.scrollLeft - startScrollPosition.left;\n        const scrollY = moveData.scrollTop - startScrollPosition.top;\n        return Object.assign(Object.assign({}, moveData), {\n          x: moveData.transformX + scrollX,\n          y: moveData.transformY + scrollY\n        });\n      }), filter(({\n        x,\n        y,\n        transformX,\n        transformY\n      }) => !this.validateDrag || this.validateDrag({\n        x,\n        y,\n        transform: {\n          x: transformX,\n          y: transformY\n        }\n      })), takeUntil(dragComplete$), share());\n      const dragStarted$ = pointerMove.pipe(take(1), share());\n      const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n      dragStarted$.subscribe(({\n        clientX,\n        clientY,\n        x,\n        y\n      }) => {\n        this.zone.run(() => {\n          this.dragStart.next({\n            cancelDrag$\n          });\n        });\n        this.scroller = autoScroll([this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : this.document.defaultView], Object.assign(Object.assign({}, this.autoScroll), {\n          autoScroll() {\n            return true;\n          }\n\n        }));\n        addClass(this.renderer, this.element, this.dragActiveClass);\n\n        if (this.ghostDragEnabled) {\n          const rect = this.element.nativeElement.getBoundingClientRect();\n          const clone = this.element.nativeElement.cloneNode(true);\n\n          if (!this.showOriginalElementWhileDragging) {\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n          }\n\n          if (this.ghostElementAppendTo) {\n            this.ghostElementAppendTo.appendChild(clone);\n          } else {\n            this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n          }\n\n          this.ghostElement = clone;\n          this.document.body.style.cursor = this.dragCursor;\n          this.setElementStyles(clone, {\n            position: 'fixed',\n            top: `${rect.top}px`,\n            left: `${rect.left}px`,\n            width: `${rect.width}px`,\n            height: `${rect.height}px`,\n            cursor: this.dragCursor,\n            margin: '0',\n            willChange: 'transform',\n            pointerEvents: 'none'\n          });\n\n          if (this.ghostElementTemplate) {\n            const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n            clone.innerHTML = '';\n            viewRef.rootNodes.filter(node => node instanceof Node).forEach(node => {\n              clone.appendChild(node);\n            });\n            dragEnded$.subscribe(() => {\n              this.vcr.remove(this.vcr.indexOf(viewRef));\n            });\n          }\n\n          this.zone.run(() => {\n            this.ghostElementCreated.emit({\n              clientX: clientX - x,\n              clientY: clientY - y,\n              element: clone\n            });\n          });\n          dragEnded$.subscribe(() => {\n            clone.parentElement.removeChild(clone);\n            this.ghostElement = null;\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n          });\n        }\n\n        this.draggableHelper.currentDrag.next(currentDrag$);\n      });\n      dragEnded$.pipe(mergeMap(dragEndData => {\n        const dragEndData$ = cancelDrag$.pipe(count(), take(1), map(calledCount => Object.assign(Object.assign({}, dragEndData), {\n          dragCancelled: calledCount > 0\n        })));\n        cancelDrag$.complete();\n        return dragEndData$;\n      })).subscribe(({\n        x,\n        y,\n        dragCancelled\n      }) => {\n        this.scroller.destroy();\n        this.zone.run(() => {\n          this.dragEnd.next({\n            x,\n            y,\n            dragCancelled\n          });\n        });\n        removeClass(this.renderer, this.element, this.dragActiveClass);\n        currentDrag$.complete();\n      });\n      merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(() => {\n        requestAnimationFrame(() => {\n          this.document.head.removeChild(globalDragStyle);\n        });\n      });\n      return pointerMove;\n    }), share());\n    merge(pointerDragged$.pipe(take(1), map(value => [, value])), pointerDragged$.pipe(pairwise())).pipe(filter(([previous, next]) => {\n      if (!previous) {\n        return true;\n      }\n\n      return previous.x !== next.x || previous.y !== next.y;\n    }), map(([previous, next]) => next)).subscribe(({\n      x,\n      y,\n      currentDrag$,\n      clientX,\n      clientY,\n      transformX,\n      transformY,\n      target\n    }) => {\n      this.zone.run(() => {\n        this.dragging.next({\n          x,\n          y\n        });\n      });\n      requestAnimationFrame(() => {\n        if (this.ghostElement) {\n          const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n          this.setElementStyles(this.ghostElement, {\n            transform,\n            '-webkit-transform': transform,\n            '-ms-transform': transform,\n            '-moz-transform': transform,\n            '-o-transform': transform\n          });\n        }\n      });\n      currentDrag$.next({\n        clientX,\n        clientY,\n        dropData: this.dropData,\n        target\n      });\n    });\n  }\n\n  ngOnChanges(changes) {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy() {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n\n  checkEventListeners() {\n    const canDrag = this.canDrag();\n    const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', event => {\n          this.onMouseDown(event);\n        });\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', event => {\n          this.onMouseUp(event);\n        });\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', event => {\n          this.onTouchStart(event);\n        });\n        this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', () => {\n          this.onMouseEnter();\n        });\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', () => {\n          this.onMouseLeave();\n        });\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  onMouseDown(event) {\n    if (event.button === 0) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', mouseMoveEvent => {\n          this.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        });\n      }\n\n      this.pointerDown$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n\n  onMouseUp(event) {\n    if (event.button === 0) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n\n      this.pointerUp$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n\n  onTouchStart(event) {\n    let startScrollPosition;\n    let isDragActivated;\n    let hasContainerScrollbar;\n\n    if (this.touchStartLongPress) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n\n    if (!this.eventListenerSubscriptions.touchmove) {\n      const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(e => {\n        e.preventDefault();\n      });\n      const touchMoveListener = fromEvent(this.document, 'touchmove', {\n        passive: false\n      }).subscribe(touchMoveEvent => {\n        if (this.touchStartLongPress && !isDragActivated && hasContainerScrollbar) {\n          isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n        }\n\n        if (!this.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n          touchMoveEvent.preventDefault();\n          this.pointerMove$.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        }\n      });\n\n      this.eventListenerSubscriptions.touchmove = () => {\n        contextMenuListener.unsubscribe();\n        touchMoveListener.unsubscribe();\n      };\n    }\n\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n\n  onTouchEnd(event) {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n\n      if (this.touchStartLongPress) {\n        this.enableScroll();\n      }\n    }\n\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n\n  onMouseEnter() {\n    this.setCursor(this.dragCursor);\n  }\n\n  onMouseLeave() {\n    this.setCursor('');\n  }\n\n  canDrag() {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  setCursor(value) {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n  }\n\n  unsubscribeEventListeners() {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      this.eventListenerSubscriptions[type]();\n      delete this.eventListenerSubscriptions[type];\n    });\n  }\n\n  setElementStyles(element, styles) {\n    Object.keys(styles).forEach(key => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n\n  getScrollElement() {\n    if (this.scrollContainer) {\n      return this.scrollContainer.elementRef.nativeElement;\n    } else {\n      return this.document.body;\n    }\n  }\n\n  getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n      };\n    } else {\n      return {\n        top: window.pageYOffset || this.document.documentElement.scrollTop,\n        left: window.pageXOffset || this.document.documentElement.scrollLeft\n      };\n    }\n  }\n\n  shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n    const moveScrollPosition = this.getScrollPosition();\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n    };\n    const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n    const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n    const deltaTotal = deltaX + deltaY;\n    const longPressConfig = this.touchStartLongPress;\n\n    if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n\n    this.timeLongPress.timerEnd = Date.now();\n    const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n    if (duration >= longPressConfig.delay) {\n      this.disableScroll();\n      return true;\n    }\n\n    return false;\n  }\n\n  enableScroll() {\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n    }\n\n    this.renderer.setStyle(this.document.body, 'overflow', '');\n  }\n\n  disableScroll() {\n    /* istanbul ignore next */\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n    }\n\n    this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n  }\n\n  hasScrollbar() {\n    const scrollContainer = this.getScrollElement();\n    const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n    const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n\n}\n\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DraggableHelper), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), i0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nDraggableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dropData: \"dropData\",\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n    validateDrag: \"validateDrag\",\n    dragCursor: \"dragCursor\",\n    dragActiveClass: \"dragActiveClass\",\n    ghostElementAppendTo: \"ghostElementAppendTo\",\n    ghostElementTemplate: \"ghostElementTemplate\",\n    touchStartLongPress: \"touchStartLongPress\",\n    autoScroll: \"autoScroll\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    ghostElementCreated: \"ghostElementCreated\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    dropData: [{\n      type: Input\n    }],\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    showOriginalElementWhileDragging: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    ghostElementAppendTo: [{\n      type: Input\n    }],\n    ghostElementTemplate: [{\n      type: Input\n    }],\n    touchStartLongPress: [{\n      type: Input\n    }],\n    autoScroll: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    ghostElementCreated: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }]\n  });\n})();\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nclass DroppableDirective {\n  constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.renderer = renderer;\n    this.scrollContainer = scrollContainer;\n    /**\n     * Called when a draggable element starts overlapping the element\n     */\n\n    this.dragEnter = new EventEmitter();\n    /**\n     * Called when a draggable element stops overlapping the element\n     */\n\n    this.dragLeave = new EventEmitter();\n    /**\n     * Called when a draggable element is moved over the element\n     */\n\n    this.dragOver = new EventEmitter();\n    /**\n     * Called when a draggable element is dropped on this element\n     */\n\n    this.drop = new EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native\n  }\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(drag$ => {\n      addClass(this.renderer, this.element, this.dragActiveClass);\n      const droppableElement = {\n        updateCache: true\n      };\n      const deregisterScrollListener = this.renderer.listen(this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window', 'scroll', () => {\n        droppableElement.updateCache = true;\n      });\n      let currentDragDropData;\n      const overlaps$ = drag$.pipe(map(({\n        clientX,\n        clientY,\n        dropData,\n        target\n      }) => {\n        currentDragDropData = dropData;\n\n        if (droppableElement.updateCache) {\n          droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n\n          if (this.scrollContainer) {\n            droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n          }\n\n          droppableElement.updateCache = false;\n        }\n\n        const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n        const isDropAllowed = !this.validateDrop || this.validateDrop({\n          clientX,\n          clientY,\n          target\n        });\n\n        if (droppableElement.scrollContainerRect) {\n          return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect);\n        } else {\n          return isWithinElement && isDropAllowed;\n        }\n      }));\n      const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n      let dragOverActive; // TODO - see if there's a way of doing this via rxjs\n\n      overlapsChanged$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n        dragOverActive = true;\n        addClass(this.renderer, this.element, this.dragOverClass);\n        this.zone.run(() => {\n          this.dragEnter.next({\n            dropData: currentDragDropData\n          });\n        });\n      });\n      overlaps$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n        this.zone.run(() => {\n          this.dragOver.next({\n            dropData: currentDragDropData\n          });\n        });\n      });\n      overlapsChanged$.pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)).subscribe(() => {\n        dragOverActive = false;\n        removeClass(this.renderer, this.element, this.dragOverClass);\n        this.zone.run(() => {\n          this.dragLeave.next({\n            dropData: currentDragDropData\n          });\n        });\n      });\n      drag$.subscribe({\n        complete: () => {\n          deregisterScrollListener();\n          removeClass(this.renderer, this.element, this.dragActiveClass);\n\n          if (dragOverActive) {\n            removeClass(this.renderer, this.element, this.dragOverClass);\n            this.zone.run(() => {\n              this.drop.next({\n                dropData: currentDragDropData\n              });\n            });\n          }\n        }\n      });\n    });\n  }\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n\n}\n\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DraggableHelper), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n};\n\nDroppableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  inputs: {\n    dragOverClass: \"dragOverClass\",\n    dragActiveClass: \"dragActiveClass\",\n    validateDrop: \"validateDrop\"\n  },\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    dragOverClass: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    validateDrop: [{\n      type: Input\n    }],\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }]\n  });\n})();\n\nclass DragAndDropModule {}\n\nDragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {\n  return new (t || DragAndDropModule)();\n};\n\nDragAndDropModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of angular-draggable-droppable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DragAndDropModule, DraggableDirective, DraggableScrollContainerDirective, DroppableDirective };","map":{"version":3,"sources":["C:/Users/p10tr/source/repos/ServiceFinderApp/node_modules/angular-draggable-droppable/fesm2015/angular-draggable-droppable.js"],"names":["i0","Injectable","Directive","EventEmitter","Optional","Inject","Input","Output","NgModule","Subject","Observable","ReplaySubject","merge","combineLatest","fromEvent","filter","mergeMap","startWith","map","share","takeUntil","take","takeLast","count","pairwise","distinctUntilChanged","DOCUMENT","autoScroll","addClass","renderer","element","classToAdd","split","forEach","className","nativeElement","removeClass","classToRemove","DraggableHelper","constructor","currentDrag","ɵfac","ɵprov","type","args","providedIn","DraggableScrollContainerDirective","elementRef","ElementRef","ɵdir","selector","DraggableDirective","draggableHelper","zone","vcr","scrollContainer","document","dragAxis","x","y","dragSnapGrid","ghostDragEnabled","showOriginalElementWhileDragging","dragCursor","margin","dragPointerDown","dragStart","ghostElementCreated","dragging","dragEnd","pointerDown$","pointerMove$","pointerUp$","eventListenerSubscriptions","destroy$","timeLongPress","timerBegin","timerEnd","ngOnInit","checkEventListeners","pointerDragged$","pipe","canDrag","pointerDownEvent","event","stopPropagation","globalDragStyle","createElement","setAttribute","appendChild","createText","requestAnimationFrame","head","startScrollPosition","getScrollPosition","scrollContainerScroll$","observer","listen","e","next","currentDrag$","cancelDrag$","run","dragComplete$","pointerMove","pointerMoveEvent","scroll","transformX","clientX","transformY","clientY","scrollLeft","left","scrollTop","top","target","moveData","Math","round","scrollX","scrollY","Object","assign","validateDrag","transform","dragStarted$","dragEnded$","subscribe","scroller","defaultView","dragActiveClass","rect","getBoundingClientRect","clone","cloneNode","setStyle","ghostElementAppendTo","parentNode","insertBefore","nextSibling","ghostElement","body","style","cursor","setElementStyles","position","width","height","willChange","pointerEvents","ghostElementTemplate","viewRef","createEmbeddedView","innerHTML","rootNodes","node","Node","remove","indexOf","emit","parentElement","removeChild","dragEndData","dragEndData$","calledCount","dragCancelled","complete","destroy","value","previous","dropData","ngOnChanges","changes","ngOnDestroy","unsubscribeEventListeners","hasEventListeners","keys","length","runOutsideAngular","mousedown","onMouseDown","mouseup","onMouseUp","touchstart","onTouchStart","touchend","onTouchEnd","touchcancel","mouseenter","onMouseEnter","mouseleave","onMouseLeave","button","mousemove","mouseMoveEvent","isDragActivated","hasContainerScrollbar","touchStartLongPress","Date","now","hasScrollbar","touchmove","contextMenuListener","preventDefault","touchMoveListener","passive","touchMoveEvent","shouldBeginDrag","targetTouches","unsubscribe","touches","enableScroll","changedTouches","setCursor","styles","key","getScrollElement","window","pageYOffset","documentElement","pageXOffset","moveScrollPosition","deltaScroll","abs","deltaX","deltaY","deltaTotal","longPressConfig","delta","duration","delay","disableScroll","containerHasHorizontalScroll","scrollWidth","clientWidth","containerHasVerticalScroll","scrollHeight","clientHeight","Renderer2","NgZone","ViewContainerRef","decorators","undefined","isCoordinateWithinRectangle","right","bottom","DroppableDirective","dragEnter","dragLeave","dragOver","drop","currentDragSubscription","drag$","droppableElement","updateCache","deregisterScrollListener","currentDragDropData","overlaps$","scrollContainerRect","isWithinElement","isDropAllowed","validateDrop","overlapsChanged$","dragOverActive","overlapsNow","dragOverClass","didOverlap","DragAndDropModule","ɵmod","ɵinj","declarations","exports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Directive, EventEmitter, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { Subject, Observable, ReplaySubject, merge, combineLatest, fromEvent } from 'rxjs';\nimport { filter, mergeMap, startWith, map, share, takeUntil, take, takeLast, count, pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\n\nfunction addClass(renderer, element, classToAdd) {\n    if (classToAdd) {\n        classToAdd\n            .split(' ')\n            .forEach((className) => renderer.addClass(element.nativeElement, className));\n    }\n}\nfunction removeClass(renderer, element, classToRemove) {\n    if (classToRemove) {\n        classToRemove\n            .split(' ')\n            .forEach((className) => renderer.removeClass(element.nativeElement, className));\n    }\n}\n\nclass DraggableHelper {\n    constructor() {\n        this.currentDrag = new Subject();\n    }\n}\nDraggableHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableHelper, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDraggableHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableHelper, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableHelper, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\nclass DraggableScrollContainerDirective {\n    /**\n     * @hidden\n     */\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n    }\n}\nDraggableScrollContainerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableScrollContainerDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\nDraggableScrollContainerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.3\", type: DraggableScrollContainerDirective, selector: \"[mwlDraggableScrollContainer]\", ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableScrollContainerDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDraggableScrollContainer]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\nclass DraggableDirective {\n    /**\n     * @hidden\n     */\n    constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n        this.element = element;\n        this.renderer = renderer;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.vcr = vcr;\n        this.scrollContainer = scrollContainer;\n        this.document = document;\n        /**\n         * The axis along which the element is draggable\n         */\n        this.dragAxis = { x: true, y: true };\n        /**\n         * Snap all drags to an x / y grid\n         */\n        this.dragSnapGrid = {};\n        /**\n         * Show a ghost element that shows the drag when dragging\n         */\n        this.ghostDragEnabled = true;\n        /**\n         * Show the original element when ghostDragEnabled is true\n         */\n        this.showOriginalElementWhileDragging = false;\n        /**\n         * The cursor to use when hovering over a draggable element\n         */\n        this.dragCursor = '';\n        /*\n         * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n         */\n        this.autoScroll = {\n            margin: 20,\n        };\n        /**\n         * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n         */\n        this.dragPointerDown = new EventEmitter();\n        /**\n         * Called when the element has started to be dragged.\n         * Only called after at least one mouse or touch move event.\n         * If you call $event.cancelDrag$.emit() it will cancel the current drag\n         */\n        this.dragStart = new EventEmitter();\n        /**\n         * Called after the ghost element has been created\n         */\n        this.ghostElementCreated = new EventEmitter();\n        /**\n         * Called when the element is being dragged\n         */\n        this.dragging = new EventEmitter();\n        /**\n         * Called after the element is dragged\n         */\n        this.dragEnd = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.pointerDown$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerMove$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerUp$ = new Subject();\n        this.eventListenerSubscriptions = {};\n        this.destroy$ = new Subject();\n        this.timeLongPress = { timerBegin: 0, timerEnd: 0 };\n    }\n    ngOnInit() {\n        this.checkEventListeners();\n        const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap((pointerDownEvent) => {\n            // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n            // stop mouse events propagating up the chain\n            if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n                pointerDownEvent.event.stopPropagation();\n            }\n            // hack to prevent text getting selected in safari while dragging\n            const globalDragStyle = this.renderer.createElement('style');\n            this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n            this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n            requestAnimationFrame(() => {\n                this.document.head.appendChild(globalDragStyle);\n            });\n            const startScrollPosition = this.getScrollPosition();\n            const scrollContainerScroll$ = new Observable((observer) => {\n                const scrollContainer = this.scrollContainer\n                    ? this.scrollContainer.elementRef.nativeElement\n                    : 'window';\n                return this.renderer.listen(scrollContainer, 'scroll', (e) => observer.next(e));\n            }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));\n            const currentDrag$ = new Subject();\n            const cancelDrag$ = new ReplaySubject();\n            this.zone.run(() => {\n                this.dragPointerDown.next({ x: 0, y: 0 });\n            });\n            const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n            const pointerMove = combineLatest([\n                this.pointerMove$,\n                scrollContainerScroll$,\n            ]).pipe(map(([pointerMoveEvent, scroll]) => {\n                return {\n                    currentDrag$,\n                    transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n                    transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n                    clientX: pointerMoveEvent.clientX,\n                    clientY: pointerMoveEvent.clientY,\n                    scrollLeft: scroll.left,\n                    scrollTop: scroll.top,\n                    target: pointerMoveEvent.event.target,\n                };\n            }), map((moveData) => {\n                if (this.dragSnapGrid.x) {\n                    moveData.transformX =\n                        Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                            this.dragSnapGrid.x;\n                }\n                if (this.dragSnapGrid.y) {\n                    moveData.transformY =\n                        Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                            this.dragSnapGrid.y;\n                }\n                return moveData;\n            }), map((moveData) => {\n                if (!this.dragAxis.x) {\n                    moveData.transformX = 0;\n                }\n                if (!this.dragAxis.y) {\n                    moveData.transformY = 0;\n                }\n                return moveData;\n            }), map((moveData) => {\n                const scrollX = moveData.scrollLeft - startScrollPosition.left;\n                const scrollY = moveData.scrollTop - startScrollPosition.top;\n                return Object.assign(Object.assign({}, moveData), { x: moveData.transformX + scrollX, y: moveData.transformY + scrollY });\n            }), filter(({ x, y, transformX, transformY }) => !this.validateDrag ||\n                this.validateDrag({\n                    x,\n                    y,\n                    transform: { x: transformX, y: transformY },\n                })), takeUntil(dragComplete$), share());\n            const dragStarted$ = pointerMove.pipe(take(1), share());\n            const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n            dragStarted$.subscribe(({ clientX, clientY, x, y }) => {\n                this.zone.run(() => {\n                    this.dragStart.next({ cancelDrag$ });\n                });\n                this.scroller = autoScroll([\n                    this.scrollContainer\n                        ? this.scrollContainer.elementRef.nativeElement\n                        : this.document.defaultView,\n                ], Object.assign(Object.assign({}, this.autoScroll), { autoScroll() {\n                        return true;\n                    } }));\n                addClass(this.renderer, this.element, this.dragActiveClass);\n                if (this.ghostDragEnabled) {\n                    const rect = this.element.nativeElement.getBoundingClientRect();\n                    const clone = this.element.nativeElement.cloneNode(true);\n                    if (!this.showOriginalElementWhileDragging) {\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n                    }\n                    if (this.ghostElementAppendTo) {\n                        this.ghostElementAppendTo.appendChild(clone);\n                    }\n                    else {\n                        this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n                    }\n                    this.ghostElement = clone;\n                    this.document.body.style.cursor = this.dragCursor;\n                    this.setElementStyles(clone, {\n                        position: 'fixed',\n                        top: `${rect.top}px`,\n                        left: `${rect.left}px`,\n                        width: `${rect.width}px`,\n                        height: `${rect.height}px`,\n                        cursor: this.dragCursor,\n                        margin: '0',\n                        willChange: 'transform',\n                        pointerEvents: 'none',\n                    });\n                    if (this.ghostElementTemplate) {\n                        const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n                        clone.innerHTML = '';\n                        viewRef.rootNodes\n                            .filter((node) => node instanceof Node)\n                            .forEach((node) => {\n                            clone.appendChild(node);\n                        });\n                        dragEnded$.subscribe(() => {\n                            this.vcr.remove(this.vcr.indexOf(viewRef));\n                        });\n                    }\n                    this.zone.run(() => {\n                        this.ghostElementCreated.emit({\n                            clientX: clientX - x,\n                            clientY: clientY - y,\n                            element: clone,\n                        });\n                    });\n                    dragEnded$.subscribe(() => {\n                        clone.parentElement.removeChild(clone);\n                        this.ghostElement = null;\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n                    });\n                }\n                this.draggableHelper.currentDrag.next(currentDrag$);\n            });\n            dragEnded$\n                .pipe(mergeMap((dragEndData) => {\n                const dragEndData$ = cancelDrag$.pipe(count(), take(1), map((calledCount) => (Object.assign(Object.assign({}, dragEndData), { dragCancelled: calledCount > 0 }))));\n                cancelDrag$.complete();\n                return dragEndData$;\n            }))\n                .subscribe(({ x, y, dragCancelled }) => {\n                this.scroller.destroy();\n                this.zone.run(() => {\n                    this.dragEnd.next({ x, y, dragCancelled });\n                });\n                removeClass(this.renderer, this.element, this.dragActiveClass);\n                currentDrag$.complete();\n            });\n            merge(dragComplete$, dragEnded$)\n                .pipe(take(1))\n                .subscribe(() => {\n                requestAnimationFrame(() => {\n                    this.document.head.removeChild(globalDragStyle);\n                });\n            });\n            return pointerMove;\n        }), share());\n        merge(pointerDragged$.pipe(take(1), map((value) => [, value])), pointerDragged$.pipe(pairwise()))\n            .pipe(filter(([previous, next]) => {\n            if (!previous) {\n                return true;\n            }\n            return previous.x !== next.x || previous.y !== next.y;\n        }), map(([previous, next]) => next))\n            .subscribe(({ x, y, currentDrag$, clientX, clientY, transformX, transformY, target, }) => {\n            this.zone.run(() => {\n                this.dragging.next({ x, y });\n            });\n            requestAnimationFrame(() => {\n                if (this.ghostElement) {\n                    const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n                    this.setElementStyles(this.ghostElement, {\n                        transform,\n                        '-webkit-transform': transform,\n                        '-ms-transform': transform,\n                        '-moz-transform': transform,\n                        '-o-transform': transform,\n                    });\n                }\n            });\n            currentDrag$.next({\n                clientX,\n                clientY,\n                dropData: this.dropData,\n                target,\n            });\n        });\n    }\n    ngOnChanges(changes) {\n        if (changes.dragAxis) {\n            this.checkEventListeners();\n        }\n    }\n    ngOnDestroy() {\n        this.unsubscribeEventListeners();\n        this.pointerDown$.complete();\n        this.pointerMove$.complete();\n        this.pointerUp$.complete();\n        this.destroy$.next();\n    }\n    checkEventListeners() {\n        const canDrag = this.canDrag();\n        const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n        if (canDrag && !hasEventListeners) {\n            this.zone.runOutsideAngular(() => {\n                this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', (event) => {\n                    this.onMouseDown(event);\n                });\n                this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', (event) => {\n                    this.onMouseUp(event);\n                });\n                this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', (event) => {\n                    this.onTouchStart(event);\n                });\n                this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', (event) => {\n                    this.onTouchEnd(event);\n                });\n                this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', (event) => {\n                    this.onTouchEnd(event);\n                });\n                this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', () => {\n                    this.onMouseEnter();\n                });\n                this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', () => {\n                    this.onMouseLeave();\n                });\n            });\n        }\n        else if (!canDrag && hasEventListeners) {\n            this.unsubscribeEventListeners();\n        }\n    }\n    onMouseDown(event) {\n        if (event.button === 0) {\n            if (!this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', (mouseMoveEvent) => {\n                    this.pointerMove$.next({\n                        event: mouseMoveEvent,\n                        clientX: mouseMoveEvent.clientX,\n                        clientY: mouseMoveEvent.clientY,\n                    });\n                });\n            }\n            this.pointerDown$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    onMouseUp(event) {\n        if (event.button === 0) {\n            if (this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove();\n                delete this.eventListenerSubscriptions.mousemove;\n            }\n            this.pointerUp$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    onTouchStart(event) {\n        let startScrollPosition;\n        let isDragActivated;\n        let hasContainerScrollbar;\n        if (this.touchStartLongPress) {\n            this.timeLongPress.timerBegin = Date.now();\n            isDragActivated = false;\n            hasContainerScrollbar = this.hasScrollbar();\n            startScrollPosition = this.getScrollPosition();\n        }\n        if (!this.eventListenerSubscriptions.touchmove) {\n            const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe((e) => {\n                e.preventDefault();\n            });\n            const touchMoveListener = fromEvent(this.document, 'touchmove', {\n                passive: false,\n            }).subscribe((touchMoveEvent) => {\n                if (this.touchStartLongPress &&\n                    !isDragActivated &&\n                    hasContainerScrollbar) {\n                    isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n                }\n                if (!this.touchStartLongPress ||\n                    !hasContainerScrollbar ||\n                    isDragActivated) {\n                    touchMoveEvent.preventDefault();\n                    this.pointerMove$.next({\n                        event: touchMoveEvent,\n                        clientX: touchMoveEvent.targetTouches[0].clientX,\n                        clientY: touchMoveEvent.targetTouches[0].clientY,\n                    });\n                }\n            });\n            this.eventListenerSubscriptions.touchmove = () => {\n                contextMenuListener.unsubscribe();\n                touchMoveListener.unsubscribe();\n            };\n        }\n        this.pointerDown$.next({\n            event,\n            clientX: event.touches[0].clientX,\n            clientY: event.touches[0].clientY,\n        });\n    }\n    onTouchEnd(event) {\n        if (this.eventListenerSubscriptions.touchmove) {\n            this.eventListenerSubscriptions.touchmove();\n            delete this.eventListenerSubscriptions.touchmove;\n            if (this.touchStartLongPress) {\n                this.enableScroll();\n            }\n        }\n        this.pointerUp$.next({\n            event,\n            clientX: event.changedTouches[0].clientX,\n            clientY: event.changedTouches[0].clientY,\n        });\n    }\n    onMouseEnter() {\n        this.setCursor(this.dragCursor);\n    }\n    onMouseLeave() {\n        this.setCursor('');\n    }\n    canDrag() {\n        return this.dragAxis.x || this.dragAxis.y;\n    }\n    setCursor(value) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n            this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n        }\n    }\n    unsubscribeEventListeners() {\n        Object.keys(this.eventListenerSubscriptions).forEach((type) => {\n            this.eventListenerSubscriptions[type]();\n            delete this.eventListenerSubscriptions[type];\n        });\n    }\n    setElementStyles(element, styles) {\n        Object.keys(styles).forEach((key) => {\n            this.renderer.setStyle(element, key, styles[key]);\n        });\n    }\n    getScrollElement() {\n        if (this.scrollContainer) {\n            return this.scrollContainer.elementRef.nativeElement;\n        }\n        else {\n            return this.document.body;\n        }\n    }\n    getScrollPosition() {\n        if (this.scrollContainer) {\n            return {\n                top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n                left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n            };\n        }\n        else {\n            return {\n                top: window.pageYOffset || this.document.documentElement.scrollTop,\n                left: window.pageXOffset || this.document.documentElement.scrollLeft,\n            };\n        }\n    }\n    shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n        const moveScrollPosition = this.getScrollPosition();\n        const deltaScroll = {\n            top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n            left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n        };\n        const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n        const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n        const deltaTotal = deltaX + deltaY;\n        const longPressConfig = this.touchStartLongPress;\n        if (deltaTotal > longPressConfig.delta ||\n            deltaScroll.top > 0 ||\n            deltaScroll.left > 0) {\n            this.timeLongPress.timerBegin = Date.now();\n        }\n        this.timeLongPress.timerEnd = Date.now();\n        const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n        if (duration >= longPressConfig.delay) {\n            this.disableScroll();\n            return true;\n        }\n        return false;\n    }\n    enableScroll() {\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', '');\n    }\n    disableScroll() {\n        /* istanbul ignore next */\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    }\n    hasScrollbar() {\n        const scrollContainer = this.getScrollElement();\n        const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n        const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n        return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n}\nDraggableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: DraggableHelper }, { token: i0.NgZone }, { token: i0.ViewContainerRef }, { token: DraggableScrollContainerDirective, optional: true }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });\nDraggableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.3\", type: DraggableDirective, selector: \"[mwlDraggable]\", inputs: { dropData: \"dropData\", dragAxis: \"dragAxis\", dragSnapGrid: \"dragSnapGrid\", ghostDragEnabled: \"ghostDragEnabled\", showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\", validateDrag: \"validateDrag\", dragCursor: \"dragCursor\", dragActiveClass: \"dragActiveClass\", ghostElementAppendTo: \"ghostElementAppendTo\", ghostElementTemplate: \"ghostElementTemplate\", touchStartLongPress: \"touchStartLongPress\", autoScroll: \"autoScroll\" }, outputs: { dragPointerDown: \"dragPointerDown\", dragStart: \"dragStart\", ghostElementCreated: \"ghostElementCreated\", dragging: \"dragging\", dragEnd: \"dragEnd\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DraggableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDraggable]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DraggableHelper }, { type: i0.NgZone }, { type: i0.ViewContainerRef }, { type: DraggableScrollContainerDirective, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }]; }, propDecorators: { dropData: [{\n                type: Input\n            }], dragAxis: [{\n                type: Input\n            }], dragSnapGrid: [{\n                type: Input\n            }], ghostDragEnabled: [{\n                type: Input\n            }], showOriginalElementWhileDragging: [{\n                type: Input\n            }], validateDrag: [{\n                type: Input\n            }], dragCursor: [{\n                type: Input\n            }], dragActiveClass: [{\n                type: Input\n            }], ghostElementAppendTo: [{\n                type: Input\n            }], ghostElementTemplate: [{\n                type: Input\n            }], touchStartLongPress: [{\n                type: Input\n            }], autoScroll: [{\n                type: Input\n            }], dragPointerDown: [{\n                type: Output\n            }], dragStart: [{\n                type: Output\n            }], ghostElementCreated: [{\n                type: Output\n            }], dragging: [{\n                type: Output\n            }], dragEnd: [{\n                type: Output\n            }] } });\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n    return (clientX >= rect.left &&\n        clientX <= rect.right &&\n        clientY >= rect.top &&\n        clientY <= rect.bottom);\n}\nclass DroppableDirective {\n    constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n        this.element = element;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.scrollContainer = scrollContainer;\n        /**\n         * Called when a draggable element starts overlapping the element\n         */\n        this.dragEnter = new EventEmitter();\n        /**\n         * Called when a draggable element stops overlapping the element\n         */\n        this.dragLeave = new EventEmitter();\n        /**\n         * Called when a draggable element is moved over the element\n         */\n        this.dragOver = new EventEmitter();\n        /**\n         * Called when a draggable element is dropped on this element\n         */\n        this.drop = new EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native\n    }\n    ngOnInit() {\n        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((drag$) => {\n            addClass(this.renderer, this.element, this.dragActiveClass);\n            const droppableElement = {\n                updateCache: true,\n            };\n            const deregisterScrollListener = this.renderer.listen(this.scrollContainer\n                ? this.scrollContainer.elementRef.nativeElement\n                : 'window', 'scroll', () => {\n                droppableElement.updateCache = true;\n            });\n            let currentDragDropData;\n            const overlaps$ = drag$.pipe(map(({ clientX, clientY, dropData, target }) => {\n                currentDragDropData = dropData;\n                if (droppableElement.updateCache) {\n                    droppableElement.rect =\n                        this.element.nativeElement.getBoundingClientRect();\n                    if (this.scrollContainer) {\n                        droppableElement.scrollContainerRect =\n                            this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n                    }\n                    droppableElement.updateCache = false;\n                }\n                const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n                const isDropAllowed = !this.validateDrop ||\n                    this.validateDrop({ clientX, clientY, target });\n                if (droppableElement.scrollContainerRect) {\n                    return (isWithinElement &&\n                        isDropAllowed &&\n                        isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect));\n                }\n                else {\n                    return isWithinElement && isDropAllowed;\n                }\n            }));\n            const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n            let dragOverActive; // TODO - see if there's a way of doing this via rxjs\n            overlapsChanged$\n                .pipe(filter((overlapsNow) => overlapsNow))\n                .subscribe(() => {\n                dragOverActive = true;\n                addClass(this.renderer, this.element, this.dragOverClass);\n                this.zone.run(() => {\n                    this.dragEnter.next({\n                        dropData: currentDragDropData,\n                    });\n                });\n            });\n            overlaps$.pipe(filter((overlapsNow) => overlapsNow)).subscribe(() => {\n                this.zone.run(() => {\n                    this.dragOver.next({\n                        dropData: currentDragDropData,\n                    });\n                });\n            });\n            overlapsChanged$\n                .pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow))\n                .subscribe(() => {\n                dragOverActive = false;\n                removeClass(this.renderer, this.element, this.dragOverClass);\n                this.zone.run(() => {\n                    this.dragLeave.next({\n                        dropData: currentDragDropData,\n                    });\n                });\n            });\n            drag$.subscribe({\n                complete: () => {\n                    deregisterScrollListener();\n                    removeClass(this.renderer, this.element, this.dragActiveClass);\n                    if (dragOverActive) {\n                        removeClass(this.renderer, this.element, this.dragOverClass);\n                        this.zone.run(() => {\n                            this.drop.next({\n                                dropData: currentDragDropData,\n                            });\n                        });\n                    }\n                },\n            });\n        });\n    }\n    ngOnDestroy() {\n        if (this.currentDragSubscription) {\n            this.currentDragSubscription.unsubscribe();\n        }\n    }\n}\nDroppableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DroppableDirective, deps: [{ token: i0.ElementRef }, { token: DraggableHelper }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: DraggableScrollContainerDirective, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\nDroppableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.3\", type: DroppableDirective, selector: \"[mwlDroppable]\", inputs: { dragOverClass: \"dragOverClass\", dragActiveClass: \"dragActiveClass\", validateDrop: \"validateDrop\" }, outputs: { dragEnter: \"dragEnter\", dragLeave: \"dragLeave\", dragOver: \"dragOver\", drop: \"drop\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DroppableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDroppable]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DraggableHelper }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: DraggableScrollContainerDirective, decorators: [{\n                    type: Optional\n                }] }]; }, propDecorators: { dragOverClass: [{\n                type: Input\n            }], dragActiveClass: [{\n                type: Input\n            }], validateDrop: [{\n                type: Input\n            }], dragEnter: [{\n                type: Output\n            }], dragLeave: [{\n                type: Output\n            }], dragOver: [{\n                type: Output\n            }], drop: [{\n                type: Output\n            }] } });\n\nclass DragAndDropModule {\n}\nDragAndDropModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DragAndDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nDragAndDropModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DragAndDropModule, declarations: [DraggableDirective,\n        DroppableDirective,\n        DraggableScrollContainerDirective], exports: [DraggableDirective,\n        DroppableDirective,\n        DraggableScrollContainerDirective] });\nDragAndDropModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DragAndDropModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: DragAndDropModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                    exports: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                }]\n        }] });\n\n/*\n * Public API Surface of angular-draggable-droppable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DragAndDropModule, DraggableDirective, DraggableScrollContainerDirective, DroppableDirective };\n"]},"metadata":{},"sourceType":"module"}