{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, PLATFORM_ID, Directive, Inject, Input, Output, Optional, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, Observable, fromEvent } from 'rxjs';\nimport { tap, share, mergeMap, take, map, pairwise, filter, takeUntil } from 'rxjs/operators';\n/**\n * @hidden\n */\n\nconst IS_TOUCH_DEVICE = (() => {\n  // In case we're in Node.js environment.\n  if (typeof window === 'undefined') {\n    return false;\n  } else {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\n  }\n})();\n/** Creates a deep clone of an element. */\n\n\nfunction deepCloneNode(node) {\n  const clone = node.cloneNode(true);\n  const descendantsWithId = clone.querySelectorAll('[id]');\n  const nodeName = node.nodeName.toLowerCase(); // Remove the `id` to avoid having multiple elements with the same id on the page.\n\n  clone.removeAttribute('id');\n  descendantsWithId.forEach(descendant => {\n    descendant.removeAttribute('id');\n  });\n\n  if (nodeName === 'canvas') {\n    transferCanvasData(node, clone);\n  } else if (nodeName === 'input' || nodeName === 'select' || nodeName === 'textarea') {\n    transferInputData(node, clone);\n  }\n\n  transferData('canvas', node, clone, transferCanvasData);\n  transferData('input, textarea, select', node, clone, transferInputData);\n  return clone;\n}\n/** Matches elements between an element and its clone and allows for their data to be cloned. */\n\n\nfunction transferData(selector, node, clone, callback) {\n  const descendantElements = node.querySelectorAll(selector);\n\n  if (descendantElements.length) {\n    const cloneElements = clone.querySelectorAll(selector);\n\n    for (let i = 0; i < descendantElements.length; i++) {\n      callback(descendantElements[i], cloneElements[i]);\n    }\n  }\n} // Counter for unique cloned radio button names.\n\n\nlet cloneUniqueId = 0;\n/** Transfers the data of one input element to another. */\n\nfunction transferInputData(source, clone) {\n  // Browsers throw an error when assigning the value of a file input programmatically.\n  if (clone.type !== 'file') {\n    clone.value = source.value;\n  } // Radio button `name` attributes must be unique for radio button groups\n  // otherwise original radio buttons can lose their checked state\n  // once the clone is inserted in the DOM.\n\n\n  if (clone.type === 'radio' && clone.name) {\n    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;\n  }\n}\n/** Transfers the data of one canvas element to another. */\n\n\nfunction transferCanvasData(source, clone) {\n  const context = clone.getContext('2d');\n\n  if (context) {\n    // In some cases `drawImage` can throw (e.g. if the canvas size is 0x0).\n    // We can't do much about it so just ignore the error.\n    try {\n      context.drawImage(source, 0, 0);\n    } catch (_a) {}\n  }\n}\n\nfunction getNewBoundingRectangle(startingRect, edges, clientX, clientY) {\n  const newBoundingRect = {\n    top: startingRect.top,\n    bottom: startingRect.bottom,\n    left: startingRect.left,\n    right: startingRect.right\n  };\n\n  if (edges.top) {\n    newBoundingRect.top += clientY;\n  }\n\n  if (edges.bottom) {\n    newBoundingRect.bottom += clientY;\n  }\n\n  if (edges.left) {\n    newBoundingRect.left += clientX;\n  }\n\n  if (edges.right) {\n    newBoundingRect.right += clientX;\n  }\n\n  newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;\n  newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;\n  return newBoundingRect;\n}\n\nfunction getElementRect(element, ghostElementPositioning) {\n  let translateX = 0;\n  let translateY = 0;\n  const style = element.nativeElement.style;\n  const transformProperties = ['transform', '-ms-transform', '-moz-transform', '-o-transform'];\n  const transform = transformProperties.map(property => style[property]).find(value => !!value);\n\n  if (transform && transform.includes('translate')) {\n    translateX = transform.replace(/.*translate3?d?\\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$1');\n    translateY = transform.replace(/.*translate3?d?\\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$2');\n  }\n\n  if (ghostElementPositioning === 'absolute') {\n    return {\n      height: element.nativeElement.offsetHeight,\n      width: element.nativeElement.offsetWidth,\n      top: element.nativeElement.offsetTop - translateY,\n      bottom: element.nativeElement.offsetHeight + element.nativeElement.offsetTop - translateY,\n      left: element.nativeElement.offsetLeft - translateX,\n      right: element.nativeElement.offsetWidth + element.nativeElement.offsetLeft - translateX\n    };\n  } else {\n    const boundingRect = element.nativeElement.getBoundingClientRect();\n    return {\n      height: boundingRect.height,\n      width: boundingRect.width,\n      top: boundingRect.top - translateY,\n      bottom: boundingRect.bottom - translateY,\n      left: boundingRect.left - translateX,\n      right: boundingRect.right - translateX,\n      scrollTop: element.nativeElement.scrollTop,\n      scrollLeft: element.nativeElement.scrollLeft\n    };\n  }\n}\n\nconst DEFAULT_RESIZE_CURSORS = Object.freeze({\n  topLeft: 'nw-resize',\n  topRight: 'ne-resize',\n  bottomLeft: 'sw-resize',\n  bottomRight: 'se-resize',\n  leftOrRight: 'col-resize',\n  topOrBottom: 'row-resize'\n});\n\nfunction getResizeCursor(edges, cursors) {\n  if (edges.left && edges.top) {\n    return cursors.topLeft;\n  } else if (edges.right && edges.top) {\n    return cursors.topRight;\n  } else if (edges.left && edges.bottom) {\n    return cursors.bottomLeft;\n  } else if (edges.right && edges.bottom) {\n    return cursors.bottomRight;\n  } else if (edges.left || edges.right) {\n    return cursors.leftOrRight;\n  } else if (edges.top || edges.bottom) {\n    return cursors.topOrBottom;\n  } else {\n    return '';\n  }\n}\n\nfunction getEdgesDiff({\n  edges,\n  initialRectangle,\n  newRectangle\n}) {\n  const edgesDiff = {};\n  Object.keys(edges).forEach(edge => {\n    edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);\n  });\n  return edgesDiff;\n}\n\nconst RESIZE_ACTIVE_CLASS = 'resize-active';\nconst RESIZE_GHOST_ELEMENT_CLASS = 'resize-ghost-element';\nconst MOUSE_MOVE_THROTTLE_MS = 50;\n/**\n * Place this on an element to make it resizable. For example:\n *\n * ```html\n * <div\n *   mwlResizable\n *   [resizeEdges]=\"{bottom: true, right: true, top: true, left: true}\"\n *   [enableGhostResize]=\"true\">\n * </div>\n * ```\n * Or in case they are sibling elements:\n * ```html\n * <div mwlResizable #resizableElement=\"mwlResizable\"></div>\n * <div mwlResizeHandle [resizableContainer]=\"resizableElement\" [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * ```\n */\n\nclass ResizableDirective {\n  /**\n   * @hidden\n   */\n  constructor(platformId, renderer, elm, zone) {\n    this.platformId = platformId;\n    this.renderer = renderer;\n    this.elm = elm;\n    this.zone = zone;\n    /**\n     * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.\n     */\n\n    this.enableGhostResize = false;\n    /**\n     * A snap grid that resize events will be locked to.\n     *\n     * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`\n     */\n\n    this.resizeSnapGrid = {};\n    /**\n     * The mouse cursors that will be set on the resize edges\n     */\n\n    this.resizeCursors = DEFAULT_RESIZE_CURSORS;\n    /**\n     * Define the positioning of the ghost element (can be fixed or absolute)\n     */\n\n    this.ghostElementPositioning = 'fixed';\n    /**\n     * Allow elements to be resized to negative dimensions\n     */\n\n    this.allowNegativeResizes = false;\n    /**\n     * The mouse move throttle in milliseconds, default: 50 ms\n     */\n\n    this.mouseMoveThrottleMS = MOUSE_MOVE_THROTTLE_MS;\n    /**\n     * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.\n     */\n\n    this.resizeStart = new EventEmitter();\n    /**\n     * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.\n     */\n\n    this.resizing = new EventEmitter();\n    /**\n     * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.\n     */\n\n    this.resizeEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.mouseup = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.mousedown = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.mousemove = new Subject();\n    this.destroy$ = new Subject();\n    this.pointerEventListeners = PointerEventListeners.getInstance(renderer, zone);\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnInit() {\n    const mousedown$ = merge(this.pointerEventListeners.pointerDown, this.mousedown);\n    const mousemove$ = merge(this.pointerEventListeners.pointerMove, this.mousemove).pipe(tap(({\n      event\n    }) => {\n      if (currentResize) {\n        try {\n          event.preventDefault();\n        } catch (e) {// just adding try-catch not to see errors in console if there is a passive listener for same event somewhere\n          // browser does nothing except of writing errors to console\n        }\n      }\n    }), share());\n    const mouseup$ = merge(this.pointerEventListeners.pointerUp, this.mouseup);\n    let currentResize;\n\n    const removeGhostElement = () => {\n      if (currentResize && currentResize.clonedNode) {\n        this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);\n        this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'inherit');\n      }\n    };\n\n    const getResizeCursors = () => {\n      return Object.assign(Object.assign({}, DEFAULT_RESIZE_CURSORS), this.resizeCursors);\n    };\n\n    const mousedrag = mousedown$.pipe(mergeMap(startCoords => {\n      function getDiff(moveCoords) {\n        return {\n          clientX: moveCoords.clientX - startCoords.clientX,\n          clientY: moveCoords.clientY - startCoords.clientY\n        };\n      }\n\n      const getSnapGrid = () => {\n        const snapGrid = {\n          x: 1,\n          y: 1\n        };\n\n        if (currentResize) {\n          if (this.resizeSnapGrid.left && currentResize.edges.left) {\n            snapGrid.x = +this.resizeSnapGrid.left;\n          } else if (this.resizeSnapGrid.right && currentResize.edges.right) {\n            snapGrid.x = +this.resizeSnapGrid.right;\n          }\n\n          if (this.resizeSnapGrid.top && currentResize.edges.top) {\n            snapGrid.y = +this.resizeSnapGrid.top;\n          } else if (this.resizeSnapGrid.bottom && currentResize.edges.bottom) {\n            snapGrid.y = +this.resizeSnapGrid.bottom;\n          }\n        }\n\n        return snapGrid;\n      };\n\n      function getGrid(coords, snapGrid) {\n        return {\n          x: Math.ceil(coords.clientX / snapGrid.x),\n          y: Math.ceil(coords.clientY / snapGrid.y)\n        };\n      }\n\n      return merge(mousemove$.pipe(take(1)).pipe(map(coords => [, coords])), mousemove$.pipe(pairwise())).pipe(map(([previousCoords, newCoords]) => {\n        return [previousCoords ? getDiff(previousCoords) : previousCoords, getDiff(newCoords)];\n      })).pipe(filter(([previousCoords, newCoords]) => {\n        if (!previousCoords) {\n          return true;\n        }\n\n        const snapGrid = getSnapGrid();\n        const previousGrid = getGrid(previousCoords, snapGrid);\n        const newGrid = getGrid(newCoords, snapGrid);\n        return previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y;\n      })).pipe(map(([, newCoords]) => {\n        const snapGrid = getSnapGrid();\n        return {\n          clientX: Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,\n          clientY: Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y\n        };\n      })).pipe(takeUntil(merge(mouseup$, mousedown$)));\n    })).pipe(filter(() => !!currentResize));\n    mousedrag.pipe(map(({\n      clientX,\n      clientY\n    }) => {\n      return getNewBoundingRectangle(currentResize.startingRect, currentResize.edges, clientX, clientY);\n    })).pipe(filter(newBoundingRect => {\n      return this.allowNegativeResizes || !!(newBoundingRect.height && newBoundingRect.width && newBoundingRect.height > 0 && newBoundingRect.width > 0);\n    })).pipe(filter(newBoundingRect => {\n      return this.validateResize ? this.validateResize({\n        rectangle: newBoundingRect,\n        edges: getEdgesDiff({\n          edges: currentResize.edges,\n          initialRectangle: currentResize.startingRect,\n          newRectangle: newBoundingRect\n        })\n      }) : true;\n    }), takeUntil(this.destroy$)).subscribe(newBoundingRect => {\n      if (currentResize && currentResize.clonedNode) {\n        this.renderer.setStyle(currentResize.clonedNode, 'height', `${newBoundingRect.height}px`);\n        this.renderer.setStyle(currentResize.clonedNode, 'width', `${newBoundingRect.width}px`);\n        this.renderer.setStyle(currentResize.clonedNode, 'top', `${newBoundingRect.top}px`);\n        this.renderer.setStyle(currentResize.clonedNode, 'left', `${newBoundingRect.left}px`);\n      }\n\n      if (this.resizing.observers.length > 0) {\n        this.zone.run(() => {\n          this.resizing.emit({\n            edges: getEdgesDiff({\n              edges: currentResize.edges,\n              initialRectangle: currentResize.startingRect,\n              newRectangle: newBoundingRect\n            }),\n            rectangle: newBoundingRect\n          });\n        });\n      }\n\n      currentResize.currentRect = newBoundingRect;\n    });\n    mousedown$.pipe(map(({\n      edges\n    }) => {\n      return edges || {};\n    }), filter(edges => {\n      return Object.keys(edges).length > 0;\n    }), takeUntil(this.destroy$)).subscribe(edges => {\n      if (currentResize) {\n        removeGhostElement();\n      }\n\n      const startingRect = getElementRect(this.elm, this.ghostElementPositioning);\n      currentResize = {\n        edges,\n        startingRect,\n        currentRect: startingRect\n      };\n      const resizeCursors = getResizeCursors();\n      const cursor = getResizeCursor(currentResize.edges, resizeCursors);\n      this.renderer.setStyle(document.body, 'cursor', cursor);\n      this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, true);\n\n      if (this.enableGhostResize) {\n        currentResize.clonedNode = deepCloneNode(this.elm.nativeElement);\n        this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);\n        this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'hidden');\n        this.renderer.setStyle(currentResize.clonedNode, 'position', this.ghostElementPositioning);\n        this.renderer.setStyle(currentResize.clonedNode, 'left', `${currentResize.startingRect.left}px`);\n        this.renderer.setStyle(currentResize.clonedNode, 'top', `${currentResize.startingRect.top}px`);\n        this.renderer.setStyle(currentResize.clonedNode, 'height', `${currentResize.startingRect.height}px`);\n        this.renderer.setStyle(currentResize.clonedNode, 'width', `${currentResize.startingRect.width}px`);\n        this.renderer.setStyle(currentResize.clonedNode, 'cursor', getResizeCursor(currentResize.edges, resizeCursors));\n        this.renderer.addClass(currentResize.clonedNode, RESIZE_GHOST_ELEMENT_CLASS);\n        currentResize.clonedNode.scrollTop = currentResize.startingRect.scrollTop;\n        currentResize.clonedNode.scrollLeft = currentResize.startingRect.scrollLeft;\n      }\n\n      if (this.resizeStart.observers.length > 0) {\n        this.zone.run(() => {\n          this.resizeStart.emit({\n            edges: getEdgesDiff({\n              edges,\n              initialRectangle: startingRect,\n              newRectangle: startingRect\n            }),\n            rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)\n          });\n        });\n      }\n    });\n    mouseup$.pipe(takeUntil(this.destroy$)).subscribe(() => {\n      if (currentResize) {\n        this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);\n        this.renderer.setStyle(document.body, 'cursor', '');\n        this.renderer.setStyle(this.elm.nativeElement, 'cursor', '');\n\n        if (this.resizeEnd.observers.length > 0) {\n          this.zone.run(() => {\n            this.resizeEnd.emit({\n              edges: getEdgesDiff({\n                edges: currentResize.edges,\n                initialRectangle: currentResize.startingRect,\n                newRectangle: currentResize.currentRect\n              }),\n              rectangle: currentResize.currentRect\n            });\n          });\n        }\n\n        removeGhostElement();\n        currentResize = null;\n      }\n    });\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnDestroy() {\n    // browser check for angular universal, because it doesn't know what document is\n    if (isPlatformBrowser(this.platformId)) {\n      this.renderer.setStyle(document.body, 'cursor', '');\n    }\n\n    this.mousedown.complete();\n    this.mouseup.complete();\n    this.mousemove.complete();\n    this.destroy$.next();\n  }\n\n  setElementClass(elm, name, add) {\n    if (add) {\n      this.renderer.addClass(elm.nativeElement, name);\n    } else {\n      this.renderer.removeClass(elm.nativeElement, name);\n    }\n  }\n\n}\n\nResizableDirective.ɵfac = function ResizableDirective_Factory(t) {\n  return new (t || ResizableDirective)(i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nResizableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ResizableDirective,\n  selectors: [[\"\", \"mwlResizable\", \"\"]],\n  inputs: {\n    validateResize: \"validateResize\",\n    enableGhostResize: \"enableGhostResize\",\n    resizeSnapGrid: \"resizeSnapGrid\",\n    resizeCursors: \"resizeCursors\",\n    ghostElementPositioning: \"ghostElementPositioning\",\n    allowNegativeResizes: \"allowNegativeResizes\",\n    mouseMoveThrottleMS: \"mouseMoveThrottleMS\"\n  },\n  outputs: {\n    resizeStart: \"resizeStart\",\n    resizing: \"resizing\",\n    resizeEnd: \"resizeEnd\"\n  },\n  exportAs: [\"mwlResizable\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResizableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlResizable]',\n      exportAs: 'mwlResizable'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    validateResize: [{\n      type: Input\n    }],\n    enableGhostResize: [{\n      type: Input\n    }],\n    resizeSnapGrid: [{\n      type: Input\n    }],\n    resizeCursors: [{\n      type: Input\n    }],\n    ghostElementPositioning: [{\n      type: Input\n    }],\n    allowNegativeResizes: [{\n      type: Input\n    }],\n    mouseMoveThrottleMS: [{\n      type: Input\n    }],\n    resizeStart: [{\n      type: Output\n    }],\n    resizing: [{\n      type: Output\n    }],\n    resizeEnd: [{\n      type: Output\n    }]\n  });\n})();\n\nclass PointerEventListeners {\n  constructor(renderer, zone) {\n    this.pointerDown = new Observable(observer => {\n      let unsubscribeMouseDown;\n      let unsubscribeTouchStart;\n      zone.runOutsideAngular(() => {\n        unsubscribeMouseDown = renderer.listen('document', 'mousedown', event => {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event\n          });\n        });\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchStart = renderer.listen('document', 'touchstart', event => {\n            observer.next({\n              clientX: event.touches[0].clientX,\n              clientY: event.touches[0].clientY,\n              event\n            });\n          });\n        }\n      });\n      return () => {\n        unsubscribeMouseDown();\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchStart();\n        }\n      };\n    }).pipe(share());\n    this.pointerMove = new Observable(observer => {\n      let unsubscribeMouseMove;\n      let unsubscribeTouchMove;\n      zone.runOutsideAngular(() => {\n        unsubscribeMouseMove = renderer.listen('document', 'mousemove', event => {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event\n          });\n        });\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchMove = renderer.listen('document', 'touchmove', event => {\n            observer.next({\n              clientX: event.targetTouches[0].clientX,\n              clientY: event.targetTouches[0].clientY,\n              event\n            });\n          });\n        }\n      });\n      return () => {\n        unsubscribeMouseMove();\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchMove();\n        }\n      };\n    }).pipe(share());\n    this.pointerUp = new Observable(observer => {\n      let unsubscribeMouseUp;\n      let unsubscribeTouchEnd;\n      let unsubscribeTouchCancel;\n      zone.runOutsideAngular(() => {\n        unsubscribeMouseUp = renderer.listen('document', 'mouseup', event => {\n          observer.next({\n            clientX: event.clientX,\n            clientY: event.clientY,\n            event\n          });\n        });\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchEnd = renderer.listen('document', 'touchend', event => {\n            observer.next({\n              clientX: event.changedTouches[0].clientX,\n              clientY: event.changedTouches[0].clientY,\n              event\n            });\n          });\n          unsubscribeTouchCancel = renderer.listen('document', 'touchcancel', event => {\n            observer.next({\n              clientX: event.changedTouches[0].clientX,\n              clientY: event.changedTouches[0].clientY,\n              event\n            });\n          });\n        }\n      });\n      return () => {\n        unsubscribeMouseUp();\n\n        if (IS_TOUCH_DEVICE) {\n          unsubscribeTouchEnd();\n          unsubscribeTouchCancel();\n        }\n      };\n    }).pipe(share());\n  }\n\n  static getInstance(renderer, zone) {\n    if (!PointerEventListeners.instance) {\n      PointerEventListeners.instance = new PointerEventListeners(renderer, zone);\n    }\n\n    return PointerEventListeners.instance;\n  }\n\n}\n/**\n * An element placed inside a `mwlResizable` directive to be used as a drag and resize handle\n *\n * For example\n *\n * ```html\n * <div mwlResizable>\n *   <div mwlResizeHandle [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * </div>\n * ```\n * Or in case they are sibling elements:\n * ```html\n * <div mwlResizable #resizableElement=\"mwlResizable\"></div>\n * <div mwlResizeHandle [resizableContainer]=\"resizableElement\" [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * ```\n */\n\n\nclass ResizeHandleDirective {\n  constructor(renderer, element, zone, resizableDirective) {\n    this.renderer = renderer;\n    this.element = element;\n    this.zone = zone;\n    this.resizableDirective = resizableDirective;\n    /**\n     * The `Edges` object that contains the edges of the parent element that dragging the handle will trigger a resize on\n     */\n\n    this.resizeEdges = {};\n    this.eventListeners = {};\n    this.destroy$ = new Subject();\n  }\n\n  ngOnInit() {\n    this.zone.runOutsideAngular(() => {\n      this.listenOnTheHost('mousedown').subscribe(event => {\n        this.onMousedown(event, event.clientX, event.clientY);\n      });\n      this.listenOnTheHost('mouseup').subscribe(event => {\n        this.onMouseup(event.clientX, event.clientY);\n      });\n\n      if (IS_TOUCH_DEVICE) {\n        this.listenOnTheHost('touchstart').subscribe(event => {\n          this.onMousedown(event, event.touches[0].clientX, event.touches[0].clientY);\n        });\n        merge(this.listenOnTheHost('touchend'), this.listenOnTheHost('touchcancel')).subscribe(event => {\n          this.onMouseup(event.changedTouches[0].clientX, event.changedTouches[0].clientY);\n        });\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.unsubscribeEventListeners();\n  }\n  /**\n   * @hidden\n   */\n\n\n  onMousedown(event, clientX, clientY) {\n    event.preventDefault();\n\n    if (!this.eventListeners.touchmove) {\n      this.eventListeners.touchmove = this.renderer.listen(this.element.nativeElement, 'touchmove', touchMoveEvent => {\n        this.onMousemove(touchMoveEvent, touchMoveEvent.targetTouches[0].clientX, touchMoveEvent.targetTouches[0].clientY);\n      });\n    }\n\n    if (!this.eventListeners.mousemove) {\n      this.eventListeners.mousemove = this.renderer.listen(this.element.nativeElement, 'mousemove', mouseMoveEvent => {\n        this.onMousemove(mouseMoveEvent, mouseMoveEvent.clientX, mouseMoveEvent.clientY);\n      });\n    }\n\n    this.resizable.mousedown.next({\n      clientX,\n      clientY,\n      edges: this.resizeEdges\n    });\n  }\n  /**\n   * @hidden\n   */\n\n\n  onMouseup(clientX, clientY) {\n    this.unsubscribeEventListeners();\n    this.resizable.mouseup.next({\n      clientX,\n      clientY,\n      edges: this.resizeEdges\n    });\n  } // directive might be passed from DI or as an input\n\n\n  get resizable() {\n    return this.resizableDirective || this.resizableContainer;\n  }\n\n  onMousemove(event, clientX, clientY) {\n    this.resizable.mousemove.next({\n      clientX,\n      clientY,\n      edges: this.resizeEdges,\n      event\n    });\n  }\n\n  unsubscribeEventListeners() {\n    Object.keys(this.eventListeners).forEach(type => {\n      this.eventListeners[type]();\n      delete this.eventListeners[type];\n    });\n  }\n\n  listenOnTheHost(eventName) {\n    return fromEvent(this.element.nativeElement, eventName).pipe(takeUntil(this.destroy$));\n  }\n\n}\n\nResizeHandleDirective.ɵfac = function ResizeHandleDirective_Factory(t) {\n  return new (t || ResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ResizableDirective, 8));\n};\n\nResizeHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ResizeHandleDirective,\n  selectors: [[\"\", \"mwlResizeHandle\", \"\"]],\n  inputs: {\n    resizeEdges: \"resizeEdges\",\n    resizableContainer: \"resizableContainer\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResizeHandleDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlResizeHandle]'\n    }]\n  }], function () {\n    return [{\n      type: i0.Renderer2\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }, {\n      type: ResizableDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    resizeEdges: [{\n      type: Input\n    }],\n    resizableContainer: [{\n      type: Input\n    }]\n  });\n})();\n\nclass ResizableModule {}\n\nResizableModule.ɵfac = function ResizableModule_Factory(t) {\n  return new (t || ResizableModule)();\n};\n\nResizableModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ResizableModule\n});\nResizableModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResizableModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [ResizableDirective, ResizeHandleDirective],\n      exports: [ResizableDirective, ResizeHandleDirective]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of angular-resizable-element\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ResizableDirective, ResizableModule, ResizeHandleDirective };","map":{"version":3,"sources":["C:/Users/p10tr/source/repos/ServiceFinderApp/node_modules/angular-resizable-element/fesm2015/angular-resizable-element.js"],"names":["i0","EventEmitter","PLATFORM_ID","Directive","Inject","Input","Output","Optional","NgModule","isPlatformBrowser","Subject","merge","Observable","fromEvent","tap","share","mergeMap","take","map","pairwise","filter","takeUntil","IS_TOUCH_DEVICE","window","navigator","maxTouchPoints","msMaxTouchPoints","deepCloneNode","node","clone","cloneNode","descendantsWithId","querySelectorAll","nodeName","toLowerCase","removeAttribute","forEach","descendant","transferCanvasData","transferInputData","transferData","selector","callback","descendantElements","length","cloneElements","i","cloneUniqueId","source","type","value","name","context","getContext","drawImage","_a","getNewBoundingRectangle","startingRect","edges","clientX","clientY","newBoundingRect","top","bottom","left","right","height","width","getElementRect","element","ghostElementPositioning","translateX","translateY","style","nativeElement","transformProperties","transform","property","find","includes","replace","offsetHeight","offsetWidth","offsetTop","offsetLeft","boundingRect","getBoundingClientRect","scrollTop","scrollLeft","DEFAULT_RESIZE_CURSORS","Object","freeze","topLeft","topRight","bottomLeft","bottomRight","leftOrRight","topOrBottom","getResizeCursor","cursors","getEdgesDiff","initialRectangle","newRectangle","edgesDiff","keys","edge","RESIZE_ACTIVE_CLASS","RESIZE_GHOST_ELEMENT_CLASS","MOUSE_MOVE_THROTTLE_MS","ResizableDirective","constructor","platformId","renderer","elm","zone","enableGhostResize","resizeSnapGrid","resizeCursors","allowNegativeResizes","mouseMoveThrottleMS","resizeStart","resizing","resizeEnd","mouseup","mousedown","mousemove","destroy$","pointerEventListeners","PointerEventListeners","getInstance","ngOnInit","mousedown$","pointerDown","mousemove$","pointerMove","pipe","event","currentResize","preventDefault","e","mouseup$","pointerUp","removeGhostElement","clonedNode","parentElement","removeChild","setStyle","getResizeCursors","assign","mousedrag","startCoords","getDiff","moveCoords","getSnapGrid","snapGrid","x","y","getGrid","coords","Math","ceil","previousCoords","newCoords","previousGrid","newGrid","round","validateResize","rectangle","subscribe","observers","run","emit","currentRect","cursor","document","body","setElementClass","appendChild","addClass","removeClass","ngOnDestroy","complete","next","add","ɵfac","Renderer2","ElementRef","NgZone","ɵdir","args","exportAs","undefined","decorators","observer","unsubscribeMouseDown","unsubscribeTouchStart","runOutsideAngular","listen","touches","unsubscribeMouseMove","unsubscribeTouchMove","targetTouches","unsubscribeMouseUp","unsubscribeTouchEnd","unsubscribeTouchCancel","changedTouches","instance","ResizeHandleDirective","resizableDirective","resizeEdges","eventListeners","listenOnTheHost","onMousedown","onMouseup","unsubscribeEventListeners","touchmove","touchMoveEvent","onMousemove","mouseMoveEvent","resizable","resizableContainer","eventName","ResizableModule","ɵmod","ɵinj","declarations","exports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { EventEmitter, PLATFORM_ID, Directive, Inject, Input, Output, Optional, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, Observable, fromEvent } from 'rxjs';\nimport { tap, share, mergeMap, take, map, pairwise, filter, takeUntil } from 'rxjs/operators';\n\n/**\n * @hidden\n */\nconst IS_TOUCH_DEVICE = (() => {\n    // In case we're in Node.js environment.\n    if (typeof window === 'undefined') {\n        return false;\n    }\n    else {\n        return ('ontouchstart' in window ||\n            navigator.maxTouchPoints > 0 ||\n            navigator.msMaxTouchPoints > 0);\n    }\n})();\n\n/** Creates a deep clone of an element. */\nfunction deepCloneNode(node) {\n    const clone = node.cloneNode(true);\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    const nodeName = node.nodeName.toLowerCase();\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    descendantsWithId.forEach((descendant) => {\n        descendant.removeAttribute('id');\n    });\n    if (nodeName === 'canvas') {\n        transferCanvasData(node, clone);\n    }\n    else if (nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'textarea') {\n        transferInputData(node, clone);\n    }\n    transferData('canvas', node, clone, transferCanvasData);\n    transferData('input, textarea, select', node, clone, transferInputData);\n    return clone;\n}\n/** Matches elements between an element and its clone and allows for their data to be cloned. */\nfunction transferData(selector, node, clone, callback) {\n    const descendantElements = node.querySelectorAll(selector);\n    if (descendantElements.length) {\n        const cloneElements = clone.querySelectorAll(selector);\n        for (let i = 0; i < descendantElements.length; i++) {\n            callback(descendantElements[i], cloneElements[i]);\n        }\n    }\n}\n// Counter for unique cloned radio button names.\nlet cloneUniqueId = 0;\n/** Transfers the data of one input element to another. */\nfunction transferInputData(source, clone) {\n    // Browsers throw an error when assigning the value of a file input programmatically.\n    if (clone.type !== 'file') {\n        clone.value = source.value;\n    }\n    // Radio button `name` attributes must be unique for radio button groups\n    // otherwise original radio buttons can lose their checked state\n    // once the clone is inserted in the DOM.\n    if (clone.type === 'radio' && clone.name) {\n        clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;\n    }\n}\n/** Transfers the data of one canvas element to another. */\nfunction transferCanvasData(source, clone) {\n    const context = clone.getContext('2d');\n    if (context) {\n        // In some cases `drawImage` can throw (e.g. if the canvas size is 0x0).\n        // We can't do much about it so just ignore the error.\n        try {\n            context.drawImage(source, 0, 0);\n        }\n        catch (_a) { }\n    }\n}\n\nfunction getNewBoundingRectangle(startingRect, edges, clientX, clientY) {\n    const newBoundingRect = {\n        top: startingRect.top,\n        bottom: startingRect.bottom,\n        left: startingRect.left,\n        right: startingRect.right,\n    };\n    if (edges.top) {\n        newBoundingRect.top += clientY;\n    }\n    if (edges.bottom) {\n        newBoundingRect.bottom += clientY;\n    }\n    if (edges.left) {\n        newBoundingRect.left += clientX;\n    }\n    if (edges.right) {\n        newBoundingRect.right += clientX;\n    }\n    newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;\n    newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;\n    return newBoundingRect;\n}\nfunction getElementRect(element, ghostElementPositioning) {\n    let translateX = 0;\n    let translateY = 0;\n    const style = element.nativeElement.style;\n    const transformProperties = [\n        'transform',\n        '-ms-transform',\n        '-moz-transform',\n        '-o-transform',\n    ];\n    const transform = transformProperties\n        .map((property) => style[property])\n        .find((value) => !!value);\n    if (transform && transform.includes('translate')) {\n        translateX = transform.replace(/.*translate3?d?\\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$1');\n        translateY = transform.replace(/.*translate3?d?\\((-?[0-9]*)px, (-?[0-9]*)px.*/, '$2');\n    }\n    if (ghostElementPositioning === 'absolute') {\n        return {\n            height: element.nativeElement.offsetHeight,\n            width: element.nativeElement.offsetWidth,\n            top: element.nativeElement.offsetTop - translateY,\n            bottom: element.nativeElement.offsetHeight +\n                element.nativeElement.offsetTop -\n                translateY,\n            left: element.nativeElement.offsetLeft - translateX,\n            right: element.nativeElement.offsetWidth +\n                element.nativeElement.offsetLeft -\n                translateX,\n        };\n    }\n    else {\n        const boundingRect = element.nativeElement.getBoundingClientRect();\n        return {\n            height: boundingRect.height,\n            width: boundingRect.width,\n            top: boundingRect.top - translateY,\n            bottom: boundingRect.bottom - translateY,\n            left: boundingRect.left - translateX,\n            right: boundingRect.right - translateX,\n            scrollTop: element.nativeElement.scrollTop,\n            scrollLeft: element.nativeElement.scrollLeft,\n        };\n    }\n}\nconst DEFAULT_RESIZE_CURSORS = Object.freeze({\n    topLeft: 'nw-resize',\n    topRight: 'ne-resize',\n    bottomLeft: 'sw-resize',\n    bottomRight: 'se-resize',\n    leftOrRight: 'col-resize',\n    topOrBottom: 'row-resize',\n});\nfunction getResizeCursor(edges, cursors) {\n    if (edges.left && edges.top) {\n        return cursors.topLeft;\n    }\n    else if (edges.right && edges.top) {\n        return cursors.topRight;\n    }\n    else if (edges.left && edges.bottom) {\n        return cursors.bottomLeft;\n    }\n    else if (edges.right && edges.bottom) {\n        return cursors.bottomRight;\n    }\n    else if (edges.left || edges.right) {\n        return cursors.leftOrRight;\n    }\n    else if (edges.top || edges.bottom) {\n        return cursors.topOrBottom;\n    }\n    else {\n        return '';\n    }\n}\nfunction getEdgesDiff({ edges, initialRectangle, newRectangle, }) {\n    const edgesDiff = {};\n    Object.keys(edges).forEach((edge) => {\n        edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);\n    });\n    return edgesDiff;\n}\nconst RESIZE_ACTIVE_CLASS = 'resize-active';\nconst RESIZE_GHOST_ELEMENT_CLASS = 'resize-ghost-element';\nconst MOUSE_MOVE_THROTTLE_MS = 50;\n/**\n * Place this on an element to make it resizable. For example:\n *\n * ```html\n * <div\n *   mwlResizable\n *   [resizeEdges]=\"{bottom: true, right: true, top: true, left: true}\"\n *   [enableGhostResize]=\"true\">\n * </div>\n * ```\n * Or in case they are sibling elements:\n * ```html\n * <div mwlResizable #resizableElement=\"mwlResizable\"></div>\n * <div mwlResizeHandle [resizableContainer]=\"resizableElement\" [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * ```\n */\nclass ResizableDirective {\n    /**\n     * @hidden\n     */\n    constructor(platformId, renderer, elm, zone) {\n        this.platformId = platformId;\n        this.renderer = renderer;\n        this.elm = elm;\n        this.zone = zone;\n        /**\n         * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.\n         */\n        this.enableGhostResize = false;\n        /**\n         * A snap grid that resize events will be locked to.\n         *\n         * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`\n         */\n        this.resizeSnapGrid = {};\n        /**\n         * The mouse cursors that will be set on the resize edges\n         */\n        this.resizeCursors = DEFAULT_RESIZE_CURSORS;\n        /**\n         * Define the positioning of the ghost element (can be fixed or absolute)\n         */\n        this.ghostElementPositioning = 'fixed';\n        /**\n         * Allow elements to be resized to negative dimensions\n         */\n        this.allowNegativeResizes = false;\n        /**\n         * The mouse move throttle in milliseconds, default: 50 ms\n         */\n        this.mouseMoveThrottleMS = MOUSE_MOVE_THROTTLE_MS;\n        /**\n         * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.\n         */\n        this.resizeStart = new EventEmitter();\n        /**\n         * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.\n         */\n        this.resizing = new EventEmitter();\n        /**\n         * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.\n         */\n        this.resizeEnd = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.mouseup = new Subject();\n        /**\n         * @hidden\n         */\n        this.mousedown = new Subject();\n        /**\n         * @hidden\n         */\n        this.mousemove = new Subject();\n        this.destroy$ = new Subject();\n        this.pointerEventListeners = PointerEventListeners.getInstance(renderer, zone);\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        const mousedown$ = merge(this.pointerEventListeners.pointerDown, this.mousedown);\n        const mousemove$ = merge(this.pointerEventListeners.pointerMove, this.mousemove).pipe(tap(({ event }) => {\n            if (currentResize) {\n                try {\n                    event.preventDefault();\n                }\n                catch (e) {\n                    // just adding try-catch not to see errors in console if there is a passive listener for same event somewhere\n                    // browser does nothing except of writing errors to console\n                }\n            }\n        }), share());\n        const mouseup$ = merge(this.pointerEventListeners.pointerUp, this.mouseup);\n        let currentResize;\n        const removeGhostElement = () => {\n            if (currentResize && currentResize.clonedNode) {\n                this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);\n                this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'inherit');\n            }\n        };\n        const getResizeCursors = () => {\n            return Object.assign(Object.assign({}, DEFAULT_RESIZE_CURSORS), this.resizeCursors);\n        };\n        const mousedrag = mousedown$\n            .pipe(mergeMap((startCoords) => {\n            function getDiff(moveCoords) {\n                return {\n                    clientX: moveCoords.clientX - startCoords.clientX,\n                    clientY: moveCoords.clientY - startCoords.clientY,\n                };\n            }\n            const getSnapGrid = () => {\n                const snapGrid = { x: 1, y: 1 };\n                if (currentResize) {\n                    if (this.resizeSnapGrid.left && currentResize.edges.left) {\n                        snapGrid.x = +this.resizeSnapGrid.left;\n                    }\n                    else if (this.resizeSnapGrid.right &&\n                        currentResize.edges.right) {\n                        snapGrid.x = +this.resizeSnapGrid.right;\n                    }\n                    if (this.resizeSnapGrid.top && currentResize.edges.top) {\n                        snapGrid.y = +this.resizeSnapGrid.top;\n                    }\n                    else if (this.resizeSnapGrid.bottom &&\n                        currentResize.edges.bottom) {\n                        snapGrid.y = +this.resizeSnapGrid.bottom;\n                    }\n                }\n                return snapGrid;\n            };\n            function getGrid(coords, snapGrid) {\n                return {\n                    x: Math.ceil(coords.clientX / snapGrid.x),\n                    y: Math.ceil(coords.clientY / snapGrid.y),\n                };\n            }\n            return merge(mousemove$.pipe(take(1)).pipe(map((coords) => [, coords])), mousemove$.pipe(pairwise()))\n                .pipe(map(([previousCoords, newCoords]) => {\n                return [\n                    previousCoords ? getDiff(previousCoords) : previousCoords,\n                    getDiff(newCoords),\n                ];\n            }))\n                .pipe(filter(([previousCoords, newCoords]) => {\n                if (!previousCoords) {\n                    return true;\n                }\n                const snapGrid = getSnapGrid();\n                const previousGrid = getGrid(previousCoords, snapGrid);\n                const newGrid = getGrid(newCoords, snapGrid);\n                return (previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y);\n            }))\n                .pipe(map(([, newCoords]) => {\n                const snapGrid = getSnapGrid();\n                return {\n                    clientX: Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,\n                    clientY: Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y,\n                };\n            }))\n                .pipe(takeUntil(merge(mouseup$, mousedown$)));\n        }))\n            .pipe(filter(() => !!currentResize));\n        mousedrag\n            .pipe(map(({ clientX, clientY }) => {\n            return getNewBoundingRectangle(currentResize.startingRect, currentResize.edges, clientX, clientY);\n        }))\n            .pipe(filter((newBoundingRect) => {\n            return (this.allowNegativeResizes ||\n                !!(newBoundingRect.height &&\n                    newBoundingRect.width &&\n                    newBoundingRect.height > 0 &&\n                    newBoundingRect.width > 0));\n        }))\n            .pipe(filter((newBoundingRect) => {\n            return this.validateResize\n                ? this.validateResize({\n                    rectangle: newBoundingRect,\n                    edges: getEdgesDiff({\n                        edges: currentResize.edges,\n                        initialRectangle: currentResize.startingRect,\n                        newRectangle: newBoundingRect,\n                    }),\n                })\n                : true;\n        }), takeUntil(this.destroy$))\n            .subscribe((newBoundingRect) => {\n            if (currentResize && currentResize.clonedNode) {\n                this.renderer.setStyle(currentResize.clonedNode, 'height', `${newBoundingRect.height}px`);\n                this.renderer.setStyle(currentResize.clonedNode, 'width', `${newBoundingRect.width}px`);\n                this.renderer.setStyle(currentResize.clonedNode, 'top', `${newBoundingRect.top}px`);\n                this.renderer.setStyle(currentResize.clonedNode, 'left', `${newBoundingRect.left}px`);\n            }\n            if (this.resizing.observers.length > 0) {\n                this.zone.run(() => {\n                    this.resizing.emit({\n                        edges: getEdgesDiff({\n                            edges: currentResize.edges,\n                            initialRectangle: currentResize.startingRect,\n                            newRectangle: newBoundingRect,\n                        }),\n                        rectangle: newBoundingRect,\n                    });\n                });\n            }\n            currentResize.currentRect = newBoundingRect;\n        });\n        mousedown$\n            .pipe(map(({ edges }) => {\n            return edges || {};\n        }), filter((edges) => {\n            return Object.keys(edges).length > 0;\n        }), takeUntil(this.destroy$))\n            .subscribe((edges) => {\n            if (currentResize) {\n                removeGhostElement();\n            }\n            const startingRect = getElementRect(this.elm, this.ghostElementPositioning);\n            currentResize = {\n                edges,\n                startingRect,\n                currentRect: startingRect,\n            };\n            const resizeCursors = getResizeCursors();\n            const cursor = getResizeCursor(currentResize.edges, resizeCursors);\n            this.renderer.setStyle(document.body, 'cursor', cursor);\n            this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, true);\n            if (this.enableGhostResize) {\n                currentResize.clonedNode = deepCloneNode(this.elm.nativeElement);\n                this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);\n                this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'hidden');\n                this.renderer.setStyle(currentResize.clonedNode, 'position', this.ghostElementPositioning);\n                this.renderer.setStyle(currentResize.clonedNode, 'left', `${currentResize.startingRect.left}px`);\n                this.renderer.setStyle(currentResize.clonedNode, 'top', `${currentResize.startingRect.top}px`);\n                this.renderer.setStyle(currentResize.clonedNode, 'height', `${currentResize.startingRect.height}px`);\n                this.renderer.setStyle(currentResize.clonedNode, 'width', `${currentResize.startingRect.width}px`);\n                this.renderer.setStyle(currentResize.clonedNode, 'cursor', getResizeCursor(currentResize.edges, resizeCursors));\n                this.renderer.addClass(currentResize.clonedNode, RESIZE_GHOST_ELEMENT_CLASS);\n                currentResize.clonedNode.scrollTop = currentResize.startingRect\n                    .scrollTop;\n                currentResize.clonedNode.scrollLeft = currentResize.startingRect\n                    .scrollLeft;\n            }\n            if (this.resizeStart.observers.length > 0) {\n                this.zone.run(() => {\n                    this.resizeStart.emit({\n                        edges: getEdgesDiff({\n                            edges,\n                            initialRectangle: startingRect,\n                            newRectangle: startingRect,\n                        }),\n                        rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0),\n                    });\n                });\n            }\n        });\n        mouseup$.pipe(takeUntil(this.destroy$)).subscribe(() => {\n            if (currentResize) {\n                this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);\n                this.renderer.setStyle(document.body, 'cursor', '');\n                this.renderer.setStyle(this.elm.nativeElement, 'cursor', '');\n                if (this.resizeEnd.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.resizeEnd.emit({\n                            edges: getEdgesDiff({\n                                edges: currentResize.edges,\n                                initialRectangle: currentResize.startingRect,\n                                newRectangle: currentResize.currentRect,\n                            }),\n                            rectangle: currentResize.currentRect,\n                        });\n                    });\n                }\n                removeGhostElement();\n                currentResize = null;\n            }\n        });\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        // browser check for angular universal, because it doesn't know what document is\n        if (isPlatformBrowser(this.platformId)) {\n            this.renderer.setStyle(document.body, 'cursor', '');\n        }\n        this.mousedown.complete();\n        this.mouseup.complete();\n        this.mousemove.complete();\n        this.destroy$.next();\n    }\n    setElementClass(elm, name, add) {\n        if (add) {\n            this.renderer.addClass(elm.nativeElement, name);\n        }\n        else {\n            this.renderer.removeClass(elm.nativeElement, name);\n        }\n    }\n}\nResizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: ResizableDirective, deps: [{ token: PLATFORM_ID }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nResizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.3\", type: ResizableDirective, selector: \"[mwlResizable]\", inputs: { validateResize: \"validateResize\", enableGhostResize: \"enableGhostResize\", resizeSnapGrid: \"resizeSnapGrid\", resizeCursors: \"resizeCursors\", ghostElementPositioning: \"ghostElementPositioning\", allowNegativeResizes: \"allowNegativeResizes\", mouseMoveThrottleMS: \"mouseMoveThrottleMS\" }, outputs: { resizeStart: \"resizeStart\", resizing: \"resizing\", resizeEnd: \"resizeEnd\" }, exportAs: [\"mwlResizable\"], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: ResizableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlResizable]',\n                    exportAs: 'mwlResizable',\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { validateResize: [{\n                type: Input\n            }], enableGhostResize: [{\n                type: Input\n            }], resizeSnapGrid: [{\n                type: Input\n            }], resizeCursors: [{\n                type: Input\n            }], ghostElementPositioning: [{\n                type: Input\n            }], allowNegativeResizes: [{\n                type: Input\n            }], mouseMoveThrottleMS: [{\n                type: Input\n            }], resizeStart: [{\n                type: Output\n            }], resizing: [{\n                type: Output\n            }], resizeEnd: [{\n                type: Output\n            }] } });\nclass PointerEventListeners {\n    constructor(renderer, zone) {\n        this.pointerDown = new Observable((observer) => {\n            let unsubscribeMouseDown;\n            let unsubscribeTouchStart;\n            zone.runOutsideAngular(() => {\n                unsubscribeMouseDown = renderer.listen('document', 'mousedown', (event) => {\n                    observer.next({\n                        clientX: event.clientX,\n                        clientY: event.clientY,\n                        event,\n                    });\n                });\n                if (IS_TOUCH_DEVICE) {\n                    unsubscribeTouchStart = renderer.listen('document', 'touchstart', (event) => {\n                        observer.next({\n                            clientX: event.touches[0].clientX,\n                            clientY: event.touches[0].clientY,\n                            event,\n                        });\n                    });\n                }\n            });\n            return () => {\n                unsubscribeMouseDown();\n                if (IS_TOUCH_DEVICE) {\n                    unsubscribeTouchStart();\n                }\n            };\n        }).pipe(share());\n        this.pointerMove = new Observable((observer) => {\n            let unsubscribeMouseMove;\n            let unsubscribeTouchMove;\n            zone.runOutsideAngular(() => {\n                unsubscribeMouseMove = renderer.listen('document', 'mousemove', (event) => {\n                    observer.next({\n                        clientX: event.clientX,\n                        clientY: event.clientY,\n                        event,\n                    });\n                });\n                if (IS_TOUCH_DEVICE) {\n                    unsubscribeTouchMove = renderer.listen('document', 'touchmove', (event) => {\n                        observer.next({\n                            clientX: event.targetTouches[0].clientX,\n                            clientY: event.targetTouches[0].clientY,\n                            event,\n                        });\n                    });\n                }\n            });\n            return () => {\n                unsubscribeMouseMove();\n                if (IS_TOUCH_DEVICE) {\n                    unsubscribeTouchMove();\n                }\n            };\n        }).pipe(share());\n        this.pointerUp = new Observable((observer) => {\n            let unsubscribeMouseUp;\n            let unsubscribeTouchEnd;\n            let unsubscribeTouchCancel;\n            zone.runOutsideAngular(() => {\n                unsubscribeMouseUp = renderer.listen('document', 'mouseup', (event) => {\n                    observer.next({\n                        clientX: event.clientX,\n                        clientY: event.clientY,\n                        event,\n                    });\n                });\n                if (IS_TOUCH_DEVICE) {\n                    unsubscribeTouchEnd = renderer.listen('document', 'touchend', (event) => {\n                        observer.next({\n                            clientX: event.changedTouches[0].clientX,\n                            clientY: event.changedTouches[0].clientY,\n                            event,\n                        });\n                    });\n                    unsubscribeTouchCancel = renderer.listen('document', 'touchcancel', (event) => {\n                        observer.next({\n                            clientX: event.changedTouches[0].clientX,\n                            clientY: event.changedTouches[0].clientY,\n                            event,\n                        });\n                    });\n                }\n            });\n            return () => {\n                unsubscribeMouseUp();\n                if (IS_TOUCH_DEVICE) {\n                    unsubscribeTouchEnd();\n                    unsubscribeTouchCancel();\n                }\n            };\n        }).pipe(share());\n    }\n    static getInstance(renderer, zone) {\n        if (!PointerEventListeners.instance) {\n            PointerEventListeners.instance = new PointerEventListeners(renderer, zone);\n        }\n        return PointerEventListeners.instance;\n    }\n}\n\n/**\n * An element placed inside a `mwlResizable` directive to be used as a drag and resize handle\n *\n * For example\n *\n * ```html\n * <div mwlResizable>\n *   <div mwlResizeHandle [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * </div>\n * ```\n * Or in case they are sibling elements:\n * ```html\n * <div mwlResizable #resizableElement=\"mwlResizable\"></div>\n * <div mwlResizeHandle [resizableContainer]=\"resizableElement\" [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * ```\n */\nclass ResizeHandleDirective {\n    constructor(renderer, element, zone, resizableDirective) {\n        this.renderer = renderer;\n        this.element = element;\n        this.zone = zone;\n        this.resizableDirective = resizableDirective;\n        /**\n         * The `Edges` object that contains the edges of the parent element that dragging the handle will trigger a resize on\n         */\n        this.resizeEdges = {};\n        this.eventListeners = {};\n        this.destroy$ = new Subject();\n    }\n    ngOnInit() {\n        this.zone.runOutsideAngular(() => {\n            this.listenOnTheHost('mousedown').subscribe((event) => {\n                this.onMousedown(event, event.clientX, event.clientY);\n            });\n            this.listenOnTheHost('mouseup').subscribe((event) => {\n                this.onMouseup(event.clientX, event.clientY);\n            });\n            if (IS_TOUCH_DEVICE) {\n                this.listenOnTheHost('touchstart').subscribe((event) => {\n                    this.onMousedown(event, event.touches[0].clientX, event.touches[0].clientY);\n                });\n                merge(this.listenOnTheHost('touchend'), this.listenOnTheHost('touchcancel')).subscribe((event) => {\n                    this.onMouseup(event.changedTouches[0].clientX, event.changedTouches[0].clientY);\n                });\n            }\n        });\n    }\n    ngOnDestroy() {\n        this.destroy$.next();\n        this.unsubscribeEventListeners();\n    }\n    /**\n     * @hidden\n     */\n    onMousedown(event, clientX, clientY) {\n        event.preventDefault();\n        if (!this.eventListeners.touchmove) {\n            this.eventListeners.touchmove = this.renderer.listen(this.element.nativeElement, 'touchmove', (touchMoveEvent) => {\n                this.onMousemove(touchMoveEvent, touchMoveEvent.targetTouches[0].clientX, touchMoveEvent.targetTouches[0].clientY);\n            });\n        }\n        if (!this.eventListeners.mousemove) {\n            this.eventListeners.mousemove = this.renderer.listen(this.element.nativeElement, 'mousemove', (mouseMoveEvent) => {\n                this.onMousemove(mouseMoveEvent, mouseMoveEvent.clientX, mouseMoveEvent.clientY);\n            });\n        }\n        this.resizable.mousedown.next({\n            clientX,\n            clientY,\n            edges: this.resizeEdges,\n        });\n    }\n    /**\n     * @hidden\n     */\n    onMouseup(clientX, clientY) {\n        this.unsubscribeEventListeners();\n        this.resizable.mouseup.next({\n            clientX,\n            clientY,\n            edges: this.resizeEdges,\n        });\n    }\n    // directive might be passed from DI or as an input\n    get resizable() {\n        return this.resizableDirective || this.resizableContainer;\n    }\n    onMousemove(event, clientX, clientY) {\n        this.resizable.mousemove.next({\n            clientX,\n            clientY,\n            edges: this.resizeEdges,\n            event,\n        });\n    }\n    unsubscribeEventListeners() {\n        Object.keys(this.eventListeners).forEach((type) => {\n            this.eventListeners[type]();\n            delete this.eventListeners[type];\n        });\n    }\n    listenOnTheHost(eventName) {\n        return fromEvent(this.element.nativeElement, eventName).pipe(takeUntil(this.destroy$));\n    }\n}\nResizeHandleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: ResizeHandleDirective, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: ResizableDirective, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\nResizeHandleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.3\", type: ResizeHandleDirective, selector: \"[mwlResizeHandle]\", inputs: { resizeEdges: \"resizeEdges\", resizableContainer: \"resizableContainer\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: ResizeHandleDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlResizeHandle]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: ResizableDirective, decorators: [{\n                    type: Optional\n                }] }]; }, propDecorators: { resizeEdges: [{\n                type: Input\n            }], resizableContainer: [{\n                type: Input\n            }] } });\n\nclass ResizableModule {\n}\nResizableModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: ResizableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nResizableModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: ResizableModule, declarations: [ResizableDirective, ResizeHandleDirective], exports: [ResizableDirective, ResizeHandleDirective] });\nResizableModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: ResizableModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.3\", ngImport: i0, type: ResizableModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [ResizableDirective, ResizeHandleDirective],\n                    exports: [ResizableDirective, ResizeHandleDirective],\n                }]\n        }] });\n\n/*\n * Public API Surface of angular-resizable-element\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ResizableDirective, ResizableModule, ResizeHandleDirective };\n"]},"metadata":{},"sourceType":"module"}